1. 입력
1-1. scanf_s함수의 sizeof와 주소연산자 포함 유무
scanf_s ("%s" , 배열명, sizeof(배열명));
scanf_s ("%d" , &변수명);

1-2. getchar()함수가 필요한 이유
정수, 문자 순서로 입력받을 때 정확한 입력값을 받기 위해서
scanf ("%d" , &변수명);
getchar();
scanf ("%c" , &변수명);

scanf ("%d" , &변수명);
scanf (" %c" , &변수명);

2. 연산자
거짓(0)이 기본값이다. 
참은 0이아닌 모든값, 보통 1이다.

2-1. 논리  && || !
2-2. 비트 & | ~ ^
30  00000000 00000000 00000000 00011110   , 0은 생략가능하므로 00011110 

-30 -> 30의 2의 보수로 구할 수 있다.
1의 보수 11111111 11111111 11111111 11100001 
2의 보수 11111111 11111111 11111111 11100010


2-3. 시프트
>> : 좌측의 빈공간은 부호비트를 적는다.
<< : 우측의 빈공간은 0을 채운다.

2-4. 형변환
(int) 3.4
정수와 실수의 연산결과는 실수이다.

2-5.조건연산자
2-6.증감연산자(전위/후위)
2-7. 복합대입연산자

3. 데이터 범위와 오버플로우
char - 1바이트 , -128~127
unsigned char - 1바이트 , 0~255

char a = 0x7f;   //127이니 양수다.
char b = 0x9f; //159이므로 32만큼 오버플로우니 -97이다.
unsigned a =  0x7f;  //127이니 양수다.
unsigned b = 0x9f;  //, 0~255에 포함되므로 양수159다.


4. 조건문

=====
반복문-while, do while, for
함수-함수선언, 함수호출, 함수정의/매개변수, 반환형/break, continue/
반환형이 없는 함수(return;), 재귀함수
